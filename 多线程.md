# 多线程

⽤户态的多线程模型，同⼀个进程内部有多个线程，所有的线程共享同⼀个进程的内存空间，进程中定义的全局变量会被所有的线程共享；
i++在计算机中并不是原⼦操作，涉及内存取数，计算和写⼊内存⼏个环节，⽽线程的切换有可能发⽣在上述任何⼀个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

## 多线程的好处

主要原因是许多应⽤中同时发⽣多个活动，某些活动随着时间推移⽽阻塞，将这些应⽤程序分解成并发运⾏的多个线程，简化设计模型。同时多线程有共享同⼀地址空间和可⽤数据的能⼒，这是多进程没有的。
线程⽐进程开销⼩，更容易创建和释放。
多个线程是IO密集型时，多线程可以使这些活动彼此重叠运⾏，可以加快程序执⾏的速度。

## 对于线程需要考虑

线程之间有⽆先后访问顺序（线程依赖关系）
多个线程共享访问同⼀变量（同步互斥问题）
同⼀进程的多个线程共享进程的资源，除了标识线程的tid，每个线程还有⾃⼰独⽴的栈空间，线程彼此之间是⽆法访问其他线程栈上内容的。

## 进程表

为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。
每个进程占有⼀个进程表项。(有些著作称这些为进程控制块)
该表项包含了⼀个进程状态的重要信息
包括程序计数器、堆栈指针、内存分配状况、所打开⽂件的状态、账号的调度信息，以及其他在进程由运⾏态转换到就绪态或阻塞态时必须保存的信息，从⽽保证该进程随后能再次启动，就像从未中断过⼀样

## 进程切换为何⽐线程慢

涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换⽽线程不会。
因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏线程切换时不涉及虚拟地址空间的转换。
把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。
由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。

## 守护进程

守护进程是指在后台运⾏的，没有控制终端与它相连的进程。它独⽴于控制终端，周期性地执⾏某种任务。
Linux的⼤多数服务器就是⽤守护进程的⽅式实现的，如web服务器进程http等。

### 创建守护进程要点

（1）让程序在后台执⾏。
⽅法是调⽤fork()产⽣⼀个⼦进程，然后使⽗进程退出。

（2）调⽤setsid()创建⼀个新对话期。
守护进程需要摆脱⽗进程的影响，⽅法是调⽤setsid()使进程成为⼀个会话组⻓。setsid()调⽤成功后，进程成为新的会话组⻓和进程组⻓，并与原来的登录会话、进程组和控制终端脱离。

（3）禁⽌进程重新打开控制终端。
经过1和2，进程已经成为⼀个⽆终端的会话组⻓，但是它可以重新申请打开⼀个终端。为了避免这种情况发⽣，可以通过使进程不再是会话组⻓来实现。再⼀次通过fork（）创建新的⼦进程，使调⽤fork的进程退出。

（4）关闭不再需要的⽂件描述符。
⼦进程从⽗进程继承打开的⽂件描述符。如不关闭，将会浪费系统资源，造成进程所在的⽂件系统⽆法卸下以及引起⽆法预料的错误。⾸先获得最⾼⽂件描述符值，然后⽤⼀个循环程序，关闭0到最⾼⽂件描述符值的所有⽂件描述符。

（5）将当前⽬录更改为根⽬录。

（6）⼦进程从⽗进程继承的⽂件创建屏蔽字可能会拒绝某些许可权。
为防⽌这⼀点，使⽤unmask(0)将屏蔽字清零。

（7）处理SIGCHLD信号。
对于服务器进程，在请求到来时往往⽣成⼦进程处理请求。如果⼦进程等待⽗进程捕获状态，则⼦进程将成为僵⼫进程（zombie），从⽽占⽤系统资源。如果⽗进程等待⼦进程结束，将增加⽗进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，⼦进程结束时不会产⽣僵⼫进程。

## 僵⼫进程

多进程程序，⽗进程⼀般需要跟踪⼦进程的退出状态，当⼦进程退出，⽗进程在运⾏，⼦进程必须等到⽗进程捕获到了⼦进程的退出状态才真正结束。在⼦进程结束后，⽗进程读取状态前，此时⼦进程为僵⼫进程。
设置僵⼫进程的⽬的是维护⼦进程的信息，以便⽗进程在以后某个时候获取。这些信息⾄少包括进程ID，进程的终⽌状态，以及该进程使⽤的CPU时间。所以当终⽌⼦进程的⽗进程调⽤wait或waitpid时就可以得到这些信息。
但是⼦进程停⽌在僵⼫态会占据内核资源，所以需要避免僵⼫进程的产⽣或⽴即结束⼦进程的僵⼫态。

1. ⽗进程调⽤wait/waitpid等函数等待⼦进程结束，如果尚⽆⼦进程退出wait会导致⽗进程阻塞。waitpid只会等待由pid参数指定的⼦进程，同时也是⾮阻塞，⽬标进程正常退出返回⼦进程PID，还没结束返回0。

2. 在事件已经发⽣情况下执⾏⾮阻塞调⽤可以提⾼程序效率。对waitpid，最好在⼦进程退出后调⽤。使⽤SIGCHLD信号通知⽗进程，⼦进程结束。

>⽗进程中捕获信号，然后在信号处理函数中调⽤waitpid以彻底结束⼦进程

```java
static void handle_child(int sig)
{
    pid_t pid;
    int stat;
    while((pid = waitpid(-1, &stat, WNOHANG)) > 0)
    {
        //结束⼦进程的处理;
    }
}
```

1. 通过signal(SIGCHLD, SIG_IGN)通知内核对⼦进程的结束不关⼼，由内核回收。如果不想让⽗进程挂起，可以在⽗进程中加⼊⼀条语句：signal(SIGCHLD,SIG_IGN);表示⽗进程忽略SIGCHLD信号，该信号是⼦进程退出的时候向⽗进程发送的。

2. 忽略SIGCHLD信号，这常⽤于并发服务器的性能的⼀个技巧因为并发服务器常常fork很多⼦进程，⼦进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理⽅式设为忽略，可让内核把僵⼫⼦进程转交给init进程去处理，省去了⼤量僵⼫进程占⽤系统资源。

## 多进程

进程结构由以下⼏个部分组成：代码段、堆栈段、数据段。代码段是静态的⼆进制代码，多个程序可以共享。

⽗进程创建⼦进程之后，⽗、⼦进程除了pid外，⼏乎所有的部分⼏乎⼀样。

⽗、⼦进程共享全部数据，⼦进程在写数据时会使⽤写时复制技术将公共的数据重新拷⻉⼀份，之后在拷⻉出的数据上进⾏操作；不是对同⼀块数据进⾏操作；

如果⼦进程想要运⾏⾃⼰的代码段，还可以通过调⽤execv()函数重新加载新的代码段，之后就和⽗进程独⽴开了
