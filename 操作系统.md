# 操作系统

## 操作系统基础

### 什么是操作系统

操作系统(Operating System)，是介于硬件资源和应⽤程序之间的⼀个系统软件 ，能控制和管理整个计算机系统的硬件和软件资源，调度计算机的⼯作与资源的分配，进⽽为⽤户和其他软件提供服务，操作系统是计算机系统中最基本的系统软件。

如果将它理解为“掌控计算机的系统”是否更能精确的描述OS所做的事情呢？

如果要更深⼊的掌握这个问题，可以问⼀问：如果没有了操作系统，你使⽤的PC机还能⼲什么？或者说，你能够使⽤你的PC机做什么呢？

### 操作系统的特征

- 并发：并发指的是两个或多个事件在同⼀时间间隔内发⽣，计算机系统中同时存在多个运⾏的程序，因此具有处理和调度多个程序同时执⾏的能⼒。
    >⚠ 注意：并⾏和并发的区别：并发指的是同⼀时间间隔，并⾏指的是同⼀时刻。
- 共享：系统中的资源可以供内存中多个并发执⾏的进程共同使⽤。
  - 互斥共享：⼀段时间内只允许⼀个进程访问该资源。⼀段时间内只允许⼀个进程访问的资源称为临界资源。
  - 同时访问：⼀段时间内允许多个进程“同时”访问，“同时”通常是宏观的，实际上是交替的对该资源进⾏访问。
- 虚拟：把⼀个物理上的实体变为若⼲逻辑上的对应物。
- 异步：进程的执⾏并不是⼀贯到底的，⽽是以不可预知的速度向前推进。

### 操作系统的功能

>操作系统位于硬件资源之上，管理硬件资源; 应⽤程序之下，为应⽤程序提供服务，同时管理应⽤程序

1. 资源分配，资源回收
计算机必要重要的硬件资源⽆⾮就是 CPU、内存、硬盘、I/O设备。
⽽这些资源总是有限的，因此需要有效管理，资源管理最终只有两个问题：资源分配、资源回收。
**资源分配：**体现在CPU上，⽐如进程调度，多个进程同时请求CPU下，应该给哪⼀个进程呢？再⽐如内存分配，内存不够了怎么办？A进程⾮法访问了B进程的内存地址怎么办？内存内、外碎⽚问题等。
**资源回收：**考虑内存回收后的合并等等。

2. 为应⽤程序提供服务
操作系统将硬件资源的操作封装起来，提供相对统⼀的接⼝（系统调⽤）供开发者调⽤。
如果没有操作系统，应⽤程序将直接⾯对硬件，除去给开发者带来的编程困难不说，直接访问硬件，使⽤不当极有可能直接损坏硬件资源。

3. 管理应⽤程序
即控制进程的⽣命周期：进程开始时的环境配置和资源分配、进程结束后的资源回收、进程调度等。

4. 操作系统内核的功能
   1. 进程调度能⼒： 管理进程、线程，决定哪个进程、线程使⽤CPU。
   2. 内存管理能⼒： 决定内存的分配和回收。
   3. 硬件通信能⼒： 管理硬件，为进程和硬件之间提供通信。
   4. 系统调⽤能⼒： 应⽤程序进⾏更⾼限权运⾏的服务，需要系统调⽤，⽤户程序和操作系统之间的接⼝。

### 操作系统的⻆⾊

1. 管理者
    主要分为：CPU管理、内存管理、外存管理、IO管理；以及⾃⼰的健壮性和安全性管理。
    >健壮性，⼜称鲁棒性，即使很粗鲁的对待程序，它还是可以很好的运⾏。

2. 魔术师:
    ⽐如操作系统会让每个进程都觉得⾃⼰独占CPU、独占整⽚物理内存，⽽实际上每个进程都只是在某⼀时间段内占⽤CPU，仅仅只是占⽤实际⼀点点物理内存。

### ⽤户程序与操作系统的关系

>⽤户程序和操作系统之间是相互调⽤的关系

1. 操作系统的⻆度
计算机启动后启动的第⼀个软件就是操作系统，随后启动的所有进程都运⾏在操作系统之上，使⽤操作系统提供的服务，同时被操作系统监控，进程结束后也由操作系统回收。
2. 进程⻆度
调⽤操作系统提供的服务，实现⾃⼰的功能。

## 进程和线程

### 进程基础

#### 进程的概念

我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执⾏⽂件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个**运⾏中的程序，就被称为「进程」(Process)**。
根据上⾯的过程，我们可以得到进程的其中⼀个定义：**进程是具有独⽴功能的程序在⼀个数据集合上运⾏的过程，是系统进⾏资源分配和调度的⼀个独⽴单位。**

#### 进程控制块（PCB）

系统通过 进程控制块PCB 来描述进程的基本情况和运⾏状态，就进⽽控制和管理进程，它是进程存在的唯⼀标识，
其包括以下信息：

1. 进程描述信息： 进程标识符、⽤户标识符
2. 进程控制和管理信息： 进程当前状态，进程优先级
3. 进程资源分配清单： 有关内存地址空间或虚拟地址空间的信息，所打开⽂件的列表和所使⽤的 I/O 设备信息。
4. CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执⾏该进程时能从断点处继续执⾏;

`PCB`通常是通过链表的⽅式进⾏组织，把具有相同状态的进程链在⼀起，组成各种队列。

#### 并发与并⾏

1. 单个处理核在很短时间内分别执⾏多个进程，称为并发
2. 多个处理核同时执⾏多个进程称为并⾏
3. 对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，在切换前必须要记录当前进程中运⾏的状态信息，以备下次切换回来的时候可以恢复执⾏。
![并发与并⾏](./image/并发和并行.png)

#### 进程的状态切换

我们知道了并发会执⾏进程的切换，这就需要进程有运⾏状态和停⽌状态，实际上某个进程在某个时刻所处的状态分为以下⼏种状态：

- 运⾏态： 该时刻进程占⽤CPU
- 就绪态：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏
- 阻塞态：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏
- ![进程的状态切换](./image/进程的状态切换.png)

当然，进程还有另外两个基本状态：

- 创建状态（new）：进程正在被创建时的状态；
- 结束状态（Exit）：进程正在从系统中消失时的状态；

![进程的状态](./image/进程的状态.png)

如果有⼤量处于阻塞状态的进程，进程可能会占⽤着物理内存空间，所以系统通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运⾏的时候，再从硬盘换⼊到物理内存，那么，就需要⼀个新的状态，来描述进程没有占⽤实际的物理内存空间的情况，这个状态就是挂起状态。这跟阻塞状态是不⼀样，阻塞状态是等待某个事件的返回。
挂起状态可以分为两种:

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏；

![挂起状态](./image/挂起状态.png)

特点：

1. 只有就绪态和运⾏态可以相互转换，其它的都是单向转换。就绪态的进程通过调度算法从⽽获得CPU 时间，转为运⾏状态；
2. 运⾏态的进程，在分配给它的 CPU 时间⽚⽤完之后就会转为就绪状态，等待下⼀次调度。
3. 阻塞态是因缺少需要的资源从⽽由运⾏态转换⽽来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运⾏态转换为就绪态。
4. 当进程等待的外部事件发⽣时（如⼀些输⼊到达），则由阻塞态转换为就绪态，如果此时没有其他进程运⾏，则转换为运⾏态，否则该进程将处于就绪态，等待CPU空闲轮到它运⾏。

#### 进程的上下⽂切换

⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换, **进程的上下⽂切换不仅包含了虚拟内存、栈、全局变量等⽤户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

发⽣进程上下⽂切换有哪些场景:

- 进程的时间⽚耗尽
- 阻塞等待
- ⾼优先级进程运⾏
- 中断处理
- 进程通过睡眠函数 sleep 这样的⽅法将⾃⼰主动挂起

#### 进程的创建

⼀个进程可以创建另⼀个进程，此时创建者为⽗进程，被创建的进程为⼦进程，操作系统创建⼀个新进程的过程如
下：

- 为新进程分配⼀个独特的进程控制块（PCB）
- 为新进程分配所需要的资源，⽐如内存、CPU时间
- 初始化进程控制块（PCB）的各种字段，包括状态、优先级、寄存器初始值等。
- 将其状态设置为就绪状态，使其能够被调度执⾏。进程进⼊就绪队列，等待分配处理器时间。

#### 进程的终⽌

- 根据标识符，查找需要终⽌的进程的 PCB；
- 如果进程处于执⾏状态，则⽴即终⽌该进程的执⾏，然后将处理器资源分配给其他进程；
- 如果其还有⼦进程，则应将该进程的⼦进程交给 1 号进程接管；
- 将该进程所拥有的全部资源都归还给操作系统；
- 将其从 PCB 所在队列中删除；

#### 进程的阻塞

- 找到被阻塞进程的标识符对应的PCB
- 如果该进程为运⾏状态，则保护其现场，将其状态转为阻塞状态，停⽌运⾏；
- 将该 PCB 插⼊到等待队列中，将处理机资源调度给其他就绪进程

#### 进程的唤醒

- 在该事件的阻塞队列中找到相应进程的 PCB；
- 将其从阻塞队列中移出，并置其状态为就绪状态；
- 把该 PCB 插⼊到就绪队列中，等待调度程序调度；

### 线程基础

#### 什么是线程？

线程是“轻量级线程”，是进程中的⼀个实体，是程序执⾏的最⼩单元，也是**被系统独⽴调度和分配的基本单位**。
**线程是进程当中的⼀条执⾏流程**，同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的。

#### 线程的特点

- 线程是⼀个“轻量级线程”，⼀个进程中可以有多个线程，线程不拥有系统资源，但是也有PCB，创建线程使⽤的底层函数和进程⼀样，都是clone。
- 各个线程之间可以并发执⾏。
- 同⼀个进程中的各个线程共享该进程所拥有的资源。
- 进程可以蜕变成线程。

实际上，⽆论是创建进程的fork，还是创建线程的 `pthread_create`，底层实现都是调⽤同⼀个内核函数`clone`。

1. 如果复制对⽅的地址空间，那么就产出⼀个“进程”;
2. 如果共享对⽅的地址空间，就产⽣⼀个“线程”。

Linux内核是不区分进程和线程的, 只在⽤户层⾯上进⾏区分。所以，线程所有操作函数 `pthread_*` 是库函数，⽽⾮系统调⽤。

#### 进程和线程的⽐较

>进程是资源（包括内存、打开的⽂件等）分配的单位，线程是 CPU 调度的单位；

- 资源：进程是系统中拥有资源的基本单位，⽽线程不拥有系统资源（仅有⼀点必不可少的能保证运⾏的资源，⽐如寄存器和栈），但线程可以访问⾪属进程的系统资源。
- 调度：线程切换的代价远低于进程，在同⼀个进程中，线程的切换不会引起进程切换，⽽从⼀个进程中的线程切换到另⼀个进程中的线程中，会引起进程切换。
- 并发：进程可以并发执⾏，⽽⼀个进程中的多个线程之间也能并发执⾏，甚⾄不同进程中的线程也能并发执⾏，从⽽使得操作系统拥有更好的并发性，提⾼了系统资源的利⽤率和系统的吞吐量。
- 独⽴性：每个进程都拥有独⽴的地址空间和资源、除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程都不可⻅，同⼀进程中的不同线程是为了提⾼并发性以及进⾏相互之间的合作⽽创建的，它们共享进程的地址空间和资源
- 系统开销：线程所需要的开销⽐进程⼩
  - 线程的创建时间⽐进程快，因为进程在创建的过程中，还需要资源管理信息，⽐如内存管理信息、⽂件管理信息，⽽线程在创建的过程中，不会涉及这些资源管理信息，⽽是共享它们；
  - 线程的终⽌时间⽐进程快，因为线程释放的资源相⽐进程少很多；
  - 同⼀个进程内的线程切换⽐进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同⼀个进程的线程都具有同⼀个⻚表，那么在切换的时候不需要切换⻚表。⽽对于进程之间的切换，切换的时候要把⻚表给切换掉，⽽⻚表的切换过程开销是⽐较⼤的；
  - 由于同⼀进程的各线程间共享内存和⽂件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更⾼了；

所以，不管是时间效率，还是空间效率线程⽐进程都要⾼。

#### 线程的状态

- 执⾏状态：线程获得处理机正在执⾏
- 就绪状态：线程已经具备执⾏条件，只需要获得CPU就可以执⾏
- 阻塞状态：线程在执⾏中因事件受阻⽽处于暂停状态

#### 线程的实现

##### ⽤户线程(ULT)

⽤户线程是在⽤户空间实现的线程，不是由内核管理的线程，整个线程管理和调度，操作系统是不直接参与的，⽽是由⽤户级线程库函数来完成线程的管理，包括线程的创建、终⽌、同步和调度等。

优点：

1. 线程切换不需要切换到内核空间中，节省了模式切换的开销。
2. 调度算法可以是进程专⽤的，不同的进程可根据⾃身的需要，对⾃⼰的线程选择不同的调度算法。
3. ⽤户级线程的实现与操作系统平台⽆关，对线程管理的代码是属于⽤户程序的⼀部分。

缺点：

1. 由于不由操作系统调度，⼀旦⽤户线程发起系统调⽤⽽阻塞，那么此进程下⽤户线程都⽆法运⾏;
2. ⼀旦某个⽤户线程正在运⾏，只有当其交出CPU执⾏权，其他⽤户线程才可以运⾏，⽆法被打断，因为只有操作系统才有权限打断运⾏，但是操作系统不直接参与调度;
3. 由于时间⽚分配给进程，故与其他进程⽐，在多线程执⾏时，每个线程得到的时间⽚较少，执⾏会⽐较慢；

##### 内核线程(KLT)

由操作系统管理、调度，其对应的TCB是存放在内核中，这样线程的创建、终⽌和管理都是由操作系统负责。

优点：

1. 当⼀个内核线程发起系统调⽤阻塞时不会影响其它内核线程的执⾏;
2. 分配给线程，多线程的进程获得更多的 CPU 运⾏时间；

缺点：

1. 在⽀持内核线程的操作系统中，由内核来维护进程和线程的上下⽂信息，如 PCB 和 TCB；
2. 线程的创建、终⽌和切换都是通过系统调⽤的⽅式来进⾏，因此对于系统来说，系统开销⽐较⼤；

##### 轻量级线程(LWP)

**轻量级进程是内核⽀持的⽤户线程，⼀个进程可有⼀个或多个 LWP，每个 LWP 是跟内核线程⼀对⼀映射的，也就是 LWP 都是由⼀个内核线程⽀持，⽽且 LWP 是由内核管理并像普通进程⼀样被调度。**

#### 线程共享资源

- ⽂件描述符表
- 每种信号的处理⽅式
- 当前⼯作⽬录
- ⽤户ID和组ID

#### 线程⾮共享资源

- 线程id
- 处理器现场和栈指针(内核栈)
- 独⽴的栈空间(⽤户空间栈)
- errno变量
- 信号屏蔽字
- 调度优先级

#### 线程的优缺点

优点：

- 提⾼程序并发性
- 开销⼩
- 数据通信、共享数据⽅便

缺点：

- 库函数，不稳定
- 调试、编写困难、gdb不⽀持
- 对信号⽀持不好

#### 线程如何减少开销

1. 线程创建快，进程创建需要资源管理信息，⽐如内存管理信息和⽂件管理信息，⽽线程创建后是共享其所属进程的资源管理信息;
2. 线程终⽌时间快，需要回收的仅有少量寄存器和私有的栈区;
3. 线程切换快，因为线程切换仅涉及到少量寄存器和栈区，⽽进程上下⽂切换有CPU寄存器和程序计数器(CPU上下⽂)、虚拟内存空间、⻚表切换等;
4. 线程因为创建时共享了其所属进程绝⼤多数资源，因此天⽣具有很好的线程间通信交互效率。

### 进程调度

当⼀个进程的状态发⽣改变时，操作系统需要考虑是否要换⼀个进程执⾏，这就需要⽤到“进程调度算法”

#### 调度⽬标

不同的调度算法具有不同的特性，因为使⽤以下标准⽐较处理机调度算法的性能：

- CPU利⽤率：CPU是计算机系统中最重要和昂贵的资源之⼀，应该使CPU保持“忙碌”状态
- 系统吞吐量：单位时间内CPU完成作业的数量。
- 周转时间：作业从提交到作业完成所需要的时间，是作业等待、在就绪队列中排队、在处理机上运⾏及输⼊输出操作所花费时间的总和。
- 等待时间：进程处于等处理机（处于就绪队列）的时间之和，等待时间越⻓，⽤户满意度越低。
- 响应时间：⽤户提交请求到系统⾸次产⽣响应所需要的时间。

#### 进程调度⽅式

- ⾮抢占调度⽅式：当⼀个进程正在处理中，即使有更为重要的进程进⼊到就绪队列中，仍然让正在执⾏的进程继续执⾏。
- 抢占调度⽅式：当⼀个进程正在处理中，如果有更为重要的进程进⼊到就绪队列中，则允许调度程序根据某种原则去暂停正在执⾏的进程，将处理机分配给这个更为重要或紧迫的进程。

### 调度算法

![调度算法](./image/调度算法.png)

#### 先来先服务调度算法(FCFS)

**每次从就绪队列选择最先进⼊队列的进程，然后⼀直运⾏，直到进程退出或被阻塞，才会继续从队列中选择第⼀个进程接着运⾏**。
这种算法虽然看上去公平，但是如果有⼀个⻓作业需要处理，则后⾯的短作业需要处理很⻓时间。
先来先调度算法的特点是算法简单，对⻓作业⽐较有利，对短作业不利，适⽤于 CPU 繁忙型作业的系统，⽽不适⽤于 I/O 繁忙型作业的系统。

![先来先服务调度算法(FCFS)](./image/先来先服务调度算法(FCFS).png)

#### 最短作业优先调度算法（SJF）

最短作业优先调度算法从就绪队列中选择⼀个估计运⾏时间最短的作业，将之调⼊到内存中运⾏，这有利于提⾼系统的吞吐量。
但是这对⻓作业⼗分不利，由于调度程序总是优先调度短作业，将会导致⻓作业⻓期不被调度，此外该算法也没有考虑到作业的紧迫程度，因此不能保证紧迫性作业会被及时处理。

![最短作业优先调度算法(SJF)](./image/最短作业优先调度算法(SJF).png)

#### ⾼响应⽐优先调度算法

每次进⾏进程调度时，先计算「响应⽐优先级」，然后把「响应⽐优先级」最⾼的进程投⼊运⾏

$优先权 = (等待时间 + 要求服务时间) / 要求服务时间$

根据公式可以知道：

- 作业的等待时间相同时，如果要求服务时间越短，则响应⽐更⾼，有利于短作业执⾏
- 当要求服务时间相同时，响应⽐由等待时间决定，如果等待时间越⻓，则响应⽐越⾼
- 对于⻓作业，作业的响应⽐可以随着等待时间的增加⽽提⾼

#### 时间⽚轮转调度算法

每个进程被分配⼀个时间段，称为时间⽚（Quantum），即允许该进程在该时间段中运⾏。

- 如果时间⽚⽤完，进程还在运⾏，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外⼀个进程；
- 如果该进程在时间⽚结束前阻塞或结束，则 CPU ⽴即进⾏切换；

另外，时间⽚的⻓度就是⼀个很关键的点：

- 如果时间⽚设得太短会导致过多的进程上下⽂切换，降低了 CPU 效率；
- 如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓。将

⼀般来说，时间⽚设为 20ms~50ms 通常是⼀个⽐较合理的折中值。

![⾼响应⽐优先调度算法](./image/⾼响应⽐优先调度算法.png)

#### 最⾼优先级调度算法

从就绪队列中选择最⾼优先级的进程进⾏运⾏，但进程的优先级可以分为静态优先级和动态优先级

- 静态优先级：优先级在创建进程时已经确定，在进程运⾏期间保持不变，确定静态优先级的主要依据有进程类型，对资源的要求，⽤户要求。
- 动态优先级：进程运⾏过程中，根据进程运⾏时间和等待时间等因素调整进程的优先级

但是这种算法可能会导致低优先级的进程永远不被执⾏。

![最⾼优先级调度算法](./image/最⾼优先级调度算法.png)

#### 多级队列调度算法

上⾯的各种调度算法是固定且单⼀的，⽆法满⾜系统中不同⽤户对进程调度策略的不同要求，多级队列调度算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可以实施不同的调度算法。

#### 多级反馈队列调度算法

多级反馈队列调度算法融合了时间⽚轮转调度算法和优先级调度算法，通过动态调整进程的优先级和时间⽚⼤⼩，多级反馈队列调度算法可以兼顾多⽅⾯的系统⽬标

多级反馈队列调度算法的实现思想如下：

- 设置多个就绪队列，并为每个队列赋予不同的优先级。第1级队列的优先级最⾼，第2级队列的优先级次之，其余队列的优先级逐个降低。
- 赋予各个队列的进程运⾏时间⽚的⼤⼩各不相同。在优先级越⾼的队列中，每个进程的时间⽚就越⼩。例如，第 i+1 级队列的时间⽚要⽐第i级队列的时间⽚⻓1倍。
- 每个队列都采⽤FCFS算法。当新进程进⼊内存后，⾸先将它放⼊第1级队列的末尾，按FCFS原则等待调度。当轮到该进程执⾏时，如它能在该时间⽚内完成，便可撤离系统。若它在⼀个时间⽚结束时尚未完成，调度程序将其转⼊第2级队列的末尾等待调度：若它在第2级队列中运⾏⼀个时间⽚后仍未完成，再将它放⼊第3级队列…，依此类推。当进程最后被降到第n级队列后，在第n级队列中便采⽤时间⽚轮转⽅式运⾏。
- 按队列优先级调度。仅当第1级队列为空时，才调度第2级队列中的进程运⾏；仅当第 1~i-1 级队列均为空时，才会调度第i级队列中的进程运⾏。若处理机正在执⾏第i级队列中的某进程时，⼜有新进程进⼊任⼀优先级较⾼的队列，此时须⽴即把正在运⾏的进程放回到第级队列的末尾，⽽把处理机分配给新到的⾼优先级进程。

多级反馈队列的优势有以下⼏点：

- 终端型作业⽤户：短作业优先。
- 短批处理作业⽤户：周转时间较短。
- ⻓批处理作业⽤户：经过前⾯⼏个队列得到部分执⾏，不会⻓期得不到处理。

![多级反馈队列调度算法](./image/多级反馈队列调度算法.png)

### 进程通信

进程通信指的是进程之间的信息交换，进程之间⼀般是相互独⽴的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

![进程通信](./image/进程通信.png)

#### 共享存储

在通信的进程之间存在⼀块可直接访问的共享空间，通过对这⽚共享空间进⾏写/读操作实现进程之间的信息交换。

![共享存储](./image/共享存储.png)

#### 消息传递(消息队列)

若通信的进程之间不存在可直接访问的共享空间，则必须利⽤操作系统提供的消息传递⽅法进⾏进程通信，进程通过系统提供的发送消息和接收消息两个原语进⾏数据交换。

- 直接通信⽅式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
- 间接通信⽅式：发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体⼀般称为信箱。

因为在内核中每个消息体都有⼀个最⼤⻓度的限制，所以消息队列不适合**⽐较⼤数据的传输**，⽽且通信也不是很及时。

#### 管道

管道是指⽤于连接⼀个读进程和⼀个写进程以实现它们之间的通信的⼀个共享⽂件，⼜名pipe⽂件，向管道（共享⽂件）提供输⼊的发送进程（写进程），以字符流形式将⼤量的数据送⼊（写）管道：⽽接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。

- 管道传输数据是半双⼯通信，某⼀时刻只能单向传输。
- 写⼊管道中的数据遵循先⼊先出的规则
- 管道所传送的数据是⽆格式的，这要求管道的读出⽅与写⼊⽅必须事先约定好数据的格式，如多少字节算⼀个消息等
- 管道不是普通的⽂件，不属于某个⽂件系统，其只存在于内存中
- 管道在内存中对应⼀个缓冲区, 不同的系统其⼤⼩不⼀定相同
- 从管道读数据是⼀次性操作，数据⼀旦被读⾛，它就从管道中被抛弃，释放空间以便写更多的数据
- 通信效率低，不适合进程间频繁地交换数据。

##### 匿名管道和命名管道之间的区别

匿名管道：没有名字的管道，⽤完就销毁， Linux 中的 | 就是⼀个匿名管道，只适⽤于⽗⼦进程之间的通信。

命名管道：提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信，所以它可以在不相关的进程间进⾏通信

##### pipe函数

```cpp
#include <unistd.h>
/**
* 创建⽆名管道.
* @param pipefd 为int型数组的⾸地址，其存放了管道的⽂件描述符
* pipefd[0]、pipefd[1].
* @return 创建成功返回0，创建失败返回-1.
*/
int pipe(int pipefd[2]);
/**
* 当⼀个管道建⽴时，它会创建两个⽂件描述符 fd[0] 和 fd[1]。其中
* fd[0] 固定⽤于读管道，⽽ fd[1] 固定⽤于写管道。 
* ⼀般⽂件 I/O的函数都可以⽤来操作管道(lseek() 除外。）
*/
```

##### 命名管道

命名管道（FIFO）不同于匿名管道之处在于它提供了⼀个路径名与之关联，以 FIFO 的⽂件形式存在于⽂件系统中，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据.

与⽆名管道(pipe)不同之处：

1. FIFO 在⽂件系统中作为⼀个特殊的⽂件⽽存在，但 FIFO 中的内容却存放在内存中;
2. 当使⽤ FIFO 的进程退出后，FIFO ⽂件将继续保存在⽂件系统中以便以后使⽤;
3. FIFO 有名字，不相关的进程可以通过打开命名管道进⾏通信.

通过命令创建有名管道 mkfifo myPipe

通过函数创建有名管道

```cpp
#include <sys/types.h>
#include <sys/stat.h>
/**
* 命名管道的创建.
* @param pathname 普通的路径名，也就是创建后 FIFO 的名字.
* @param mode ⽂件的权限，
* 与打开普通⽂件的 open() 函数中的 mode 参数相同。(0666).
* @return 成功: 0 状态码;
* 失败: 如果⽂件已经存在，则会出错且返回 -1.
*/
int mkfifo(const char *pathname, mode_t mode);
```

#### 信号量

信号量⽤于控制多个进程对共享资源的访问，⽐如避免因为多个进程同时修改同⼀个共享内存造成冲突，信号量可以使共享的资源在任意时刻只能被⼀个进程访问

信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。
信号量维护⼀个整数值，通常称为计数器。进程可以执⾏两种基本操作来操作信号量：

- P（Wait）操作：这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。
- V（Signal）操作：这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

![PV操作](./image/PV操作.png)

如果两个进程访问共享内存，我们可以初始化信号量为1

- 进程 A 在访问共享内存前，先执⾏了 P 操作，由于信号量的初始值为 1，故在进程 A 执⾏ P 操作后信号量变为 0，表示共享资源可⽤，于是进程 A 就可以访问共享内存。
- 若此时，进程 B 也想访问共享内存，执⾏了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占⽤，因此进程 B 被阻塞。
- 直到进程 A 访问完共享内存，才会执⾏ V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执⾏ V 操作，使信号量恢复到初始值 `1`。

可以发现，信号初始化为`1`，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。

还可以使⽤信号量实现多进程同步，⽐如可以初始化信号量为0

![PV操作唤醒](./image/PV操作唤醒.png)

具体过程：

- 如果进程 B ⽐进程 A 先执⾏了，那么执⾏到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没⽣产数据，于是进程 B 就阻塞等待；
- 接着，当进程 A ⽣产完数据后，执⾏了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程B；
- 最后，进程 B 被唤醒后，意味着进程 A 已经⽣产了数据，于是进程 B 就可以正常读取数据了。

可以发现，信号初始化为 0 ，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执⾏。

#### 信号

在 Linux 操作系统中， 为了响应各种各样的事件，提供了⼏⼗种信号，分别代表不同的意义。我们可以通过 `kill-l` 命令，查看所有的信号。
信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。
信号是进程间通信机制中唯⼀的异步通信机制，它可以在⼀个进程中通知另⼀个进程发⽣了某种事件从⽽实现进程通信。

#### Socket通信

Socket 通信是⼀种⽹络编程中常⻅的通信⽅式，但它也可以在同⼀台机器上的不同进程之间进⾏通信。
创建 socket 的系统调⽤：

```cpp
int socket(int domain, int type, int protocal)
```

三个参数分别代表：

- domain 参数⽤来指定协议族，⽐如 AF_INET ⽤于 IPV4、AF_INET6 ⽤于 IPV6、AF_LOCAL/AF_UNIX ⽤于本机；

- type 参数⽤来指定通信特性，⽐如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；

- protocal 参数原本是⽤来指定通信协议的，但现在基本废弃。因为协议已经通过前⾯两个参数指定完成，protocol ⽬前⼀般写成 0 即可；

根据创建 socket 类型的不同，通信的⽅式也就不同：

- 实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；
- 实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；
- 实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地socket；

### 线程通信

线程间的通信⽬的主要是⽤于线程同步。所以线程没有像进程通信中的⽤于数据交换的通信机制。
同⼀进程的不同线程共享同⼀份内存区域，所以线程之间可以⽅便、快速地共享信息。只需要将数据复制到共享
（全局或堆）变量中即可。但是需要避免出现多个线程试图同时修改同⼀份信息。

### 线程属性

#### 线程属性初始化和销毁

```cpp
#include <pthread.h>
/**
* 初始化线程属性函数，注意：应先初始化线程属性，再pthread_create创建线程.
* @param attr 线程属性结构体.
* @return 成功: 0; 失败: 错误号.
*/
int pthread_attr_init(pthread_attr_t *attr);
/**
* 销毁线程属性所占⽤的资源函数.
* @param attr 线程属性结构体.
* @return 成功: 0; 失败: 错误号.
*/
int pthread_attr_destroy(pthread_attr_t *attr);
```

#### 线程分离状态

（1）⾮分离状态：
线程的默认属性是⾮分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回
时，创建的线程才算终⽌，才能释放⾃⼰占⽤的系统资源。

（2）分离状态：
分离线程没有被其他的线程所等待，⾃⼰运⾏结束了，线程也就终⽌了，⻢上释放系统资源。应该根据⾃⼰的需
要，选择适当的分离状态。

注意：

1. 如果设置⼀个线程为分离线程，⽽这个线程运⾏⼜⾮常快，它很可能在pthread_create函数返回之前就终⽌了，它终⽌以后就可能将线程号和系统资源移交给其他的线程使⽤，这样调⽤`pthread_create`的线程就得到了错误的线程号。
2. 要避免这种情况可以采取⼀定的同步措施，最简单的⽅法之⼀是可以在被创建的线程⾥调⽤`pthread_cond_timedwait`函数，让这个线程等待⼀会⼉，留出⾜够的时间让函数`pthread_create`返回。

```cpp
#include <pthread.h>
/**
* 设置线程分离状态.
* @param attr 已初始化的线程属性.
* @detachstate(分离状态)
* 1. PTHREAD_CREATE_DETACHED（分离线程）;
* 2. PTHREAD_CREATE_JOINABLE（⾮分离线程）.
* @return 成功: 0; 失败: ⾮0.
*/
/**
* 获取线程分离状态.
* @param attr 已初始化的线程属性.
* @detachstate(分离状态)
* 1. PTHREAD_CREATE_DETACHED（分离线程）;
* 2. PTHREAD_CREATE_JOINABLE（⾮分离线程）.
* @return 成功: 0; 失败: ⾮0.
*/
int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
```

#### 线程栈地址

当进程栈地址空间不够⽤时，指定新建线程使⽤由malloc分配的空间作为⾃⼰的栈空间。

通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。

```cpp
#include <pthread.h>
/**
* 设置线程的栈地址.
* @param attr 指向⼀个线程属性的指针.
* @param stackaddr 内存⾸地址.
* @param stacksize 返回线程的堆栈⼤⼩.
* @return 成功: 0; 失败: 错误号.
*/
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);
/**
* 获取线程的栈地址.
* @param attr 指向⼀个线程属性的指针.
* @param stackaddr 返回获取的栈地址.
* @param stacksize 返回获取的栈⼤⼩.
* @return 成功: 0; 失败: 错误号.
*/
int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t
*stacksize);
```

#### 线程栈⼤⼩

```cpp
#include <pthread.h>
/**
* 设置线程的栈⼤⼩.
* @param attr 指向⼀个线程属性的指针.
* @param stacksize 线程的堆栈⼤⼩.
* @return 成功: 0; 失败: 错误号.
*/
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
/**
* 获取线程的栈⼤⼩.
* @param attr 指向⼀个线程属性的指针.
* @param stacksize 返回线程的堆栈⼤⼩.
* @return 成功: 0; 失败: 错误号.
*/
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
```

#### 线程使⽤注意事项

1. 主线程退出其他线程不退出，主线程应调⽤pthread_exit
2. 避免僵⼫线程
   1. pthread_join
   2. pthread_detach
   3. pthread_create指定分离属性
  被join线程可能在join函数返回前就释放完⾃⼰的所有内存资源，所以不应当返回被回收线程栈中的值

3. malloc和mmap申请的内存可以被其他线程释放
4. 应避免在多线程模型中调⽤fork，除⾮⻢上exec，⼦进程中只有调⽤fork的线程存在，其他线程t在⼦进程中均pthread_exit
5. 信号的复杂语义很难和多线程共存，应避免在多线程引⼊信号机制
6. Cache伪共享：
  这种因为多个线程同时读写同⼀个 Cache Line 的不同变量时，⽽导致 CPU Cache 失效的现象。避免的⽅式⼀般有Cache Line ⼤⼩字节对⻬，以及字节填充等⽅法。在 Linux 内核中存在cachelinealignedin_smp 宏定义，是⽤于解决伪共享的问题。

## 多线程

⽤户态的多线程模型，同⼀个进程内部有多个线程，所有的线程共享同⼀个进程的内存空间，进程中定义的全局变量会被所有的线程共享；
i++在计算机中并不是原⼦操作，涉及内存取数，计算和写⼊内存⼏个环节，⽽线程的切换有可能发⽣在上述任何⼀个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

### 多线程的好处

主要原因是许多应⽤中同时发⽣多个活动，某些活动随着时间推移⽽阻塞，将这些应⽤程序分解成并发运⾏的多个线程，简化设计模型。同时多线程有共享同⼀地址空间和可⽤数据的能⼒，这是多进程没有的。
线程⽐进程开销⼩，更容易创建和释放。
多个线程是IO密集型时，多线程可以使这些活动彼此重叠运⾏，可以加快程序执⾏的速度。

### 对于线程需要考虑

线程之间有⽆先后访问顺序（线程依赖关系）
多个线程共享访问同⼀变量（同步互斥问题）
同⼀进程的多个线程共享进程的资源，除了标识线程的tid，每个线程还有⾃⼰独⽴的栈空间，线程彼此之间是⽆法访问其他线程栈上内容的。

### 进程表

为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。
每个进程占有⼀个进程表项。(有些著作称这些为进程控制块)
该表项包含了⼀个进程状态的重要信息
包括程序计数器、堆栈指针、内存分配状况、所打开⽂件的状态、账号的调度信息，以及其他在进程由运⾏态转换到就绪态或阻塞态时必须保存的信息，从⽽保证该进程随后能再次启动，就像从未中断过⼀样

### 进程切换为何⽐线程慢

涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换⽽线程不会。
因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏线程切换时不涉及虚拟地址空间的转换。
把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。
由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。

### 守护进程

守护进程是指在后台运⾏的，没有控制终端与它相连的进程。它独⽴于控制终端，周期性地执⾏某种任务。
Linux的⼤多数服务器就是⽤守护进程的⽅式实现的，如web服务器进程http等。

#### 创建守护进程要点

（1）让程序在后台执⾏。
⽅法是调⽤fork()产⽣⼀个⼦进程，然后使⽗进程退出。

（2）调⽤setsid()创建⼀个新对话期。
守护进程需要摆脱⽗进程的影响，⽅法是调⽤setsid()使进程成为⼀个会话组⻓。setsid()调⽤成功后，进程成为新的会话组⻓和进程组⻓，并与原来的登录会话、进程组和控制终端脱离。

（3）禁⽌进程重新打开控制终端。
经过1和2，进程已经成为⼀个⽆终端的会话组⻓，但是它可以重新申请打开⼀个终端。为了避免这种情况发⽣，可以通过使进程不再是会话组⻓来实现。再⼀次通过fork（）创建新的⼦进程，使调⽤fork的进程退出。

（4）关闭不再需要的⽂件描述符。
⼦进程从⽗进程继承打开的⽂件描述符。如不关闭，将会浪费系统资源，造成进程所在的⽂件系统⽆法卸下以及引起⽆法预料的错误。⾸先获得最⾼⽂件描述符值，然后⽤⼀个循环程序，关闭0到最⾼⽂件描述符值的所有⽂件描述符。

（5）将当前⽬录更改为根⽬录。

（6）⼦进程从⽗进程继承的⽂件创建屏蔽字可能会拒绝某些许可权。
为防⽌这⼀点，使⽤unmask(0)将屏蔽字清零。

（7）处理SIGCHLD信号。
对于服务器进程，在请求到来时往往⽣成⼦进程处理请求。如果⼦进程等待⽗进程捕获状态，则⼦进程将成为僵⼫进程（zombie），从⽽占⽤系统资源。如果⽗进程等待⼦进程结束，将增加⽗进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，⼦进程结束时不会产⽣僵⼫进程。

### 僵⼫进程

多进程程序，⽗进程⼀般需要跟踪⼦进程的退出状态，当⼦进程退出，⽗进程在运⾏，⼦进程必须等到⽗进程捕获到了⼦进程的退出状态才真正结束。在⼦进程结束后，⽗进程读取状态前，此时⼦进程为僵⼫进程。
设置僵⼫进程的⽬的是维护⼦进程的信息，以便⽗进程在以后某个时候获取。这些信息⾄少包括进程ID，进程的终⽌状态，以及该进程使⽤的CPU时间。所以当终⽌⼦进程的⽗进程调⽤wait或waitpid时就可以得到这些信息。
但是⼦进程停⽌在僵⼫态会占据内核资源，所以需要避免僵⼫进程的产⽣或⽴即结束⼦进程的僵⼫态。

1. ⽗进程调⽤wait/waitpid等函数等待⼦进程结束，如果尚⽆⼦进程退出wait会导致⽗进程阻塞。waitpid只会等待由pid参数指定的⼦进程，同时也是⾮阻塞，⽬标进程正常退出返回⼦进程PID，还没结束返回0。

2. 在事件已经发⽣情况下执⾏⾮阻塞调⽤可以提⾼程序效率。对waitpid，最好在⼦进程退出后调⽤。使⽤SIGCHLD信号通知⽗进程，⼦进程结束。

>⽗进程中捕获信号，然后在信号处理函数中调⽤waitpid以彻底结束⼦进程

```java
static void handle_child(int sig)
{
    pid_t pid;
    int stat;
    while((pid = waitpid(-1, &stat, WNOHANG)) > 0)
    {
        //结束⼦进程的处理;
    }
}
```

1. 通过signal(SIGCHLD, SIG_IGN)通知内核对⼦进程的结束不关⼼，由内核回收。如果不想让⽗进程挂起，可以在⽗进程中加⼊⼀条语句：signal(SIGCHLD,SIG_IGN);表示⽗进程忽略SIGCHLD信号，该信号是⼦进程退出的时候向⽗进程发送的。

2. 忽略SIGCHLD信号，这常⽤于并发服务器的性能的⼀个技巧因为并发服务器常常fork很多⼦进程，⼦进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理⽅式设为忽略，可让内核把僵⼫⼦进程转交给init进程去处理，省去了⼤量僵⼫进程占⽤系统资源。

### 多进程

进程结构由以下⼏个部分组成：代码段、堆栈段、数据段。代码段是静态的⼆进制代码，多个程序可以共享。

⽗进程创建⼦进程之后，⽗、⼦进程除了pid外，⼏乎所有的部分⼏乎⼀样。

⽗、⼦进程共享全部数据，⼦进程在写数据时会使⽤写时复制技术将公共的数据重新拷⻉⼀份，之后在拷⻉出的数据上进⾏操作；不是对同⼀块数据进⾏操作；

如果⼦进程想要运⾏⾃⼰的代码段，还可以通过调⽤execv()函数重新加载新的代码段，之后就和⽗进程独⽴开了

## 进程通信(实现)

### 共享存储映射

存储映射I/O (Memory-mapped I/O) 使⼀个磁盘⽂件与存储空间中的⼀个缓冲区相映射.
于是当从缓冲区中取数据，就相当于读⽂件中的相应字节。于此类似，将数据存⼊缓冲区，则相应的字节就⾃动写
⼊⽂件。
这样，就可在不适⽤read和write函数的情况下，使⽤地址（指针）完成I/O操作，进程就可以直接通过读写内存来
操作⽂件.
共享内存可以说是最有⽤的进程间通信⽅式，也是最快的IPC形式, 因为进程可以直接读写内存，⽽不需要任何数据
的拷⻉.

![共享存储映射](./image/共享存储映射.png)

#### 存储映射函数

##### mmap函数

```cpp
#include <sys/mman.h>
/**
* ⼀个⽂件或者其它对象映射进内存.
* @param addr 指定映射的起始地址, 通常设为NULL, 由系统指定.
* @param length 映射到内存的⽂件⻓度.
* @param prot 映射区的保护⽅式, 最常⽤的:
* (1) 读：PROT_READ;
* (2) 写：PROT_WRITE;
* (3) 读写：PROT_READ | PROT_WRITE.
* @param flags 映射区的特性, 可以是:
* (1) MAP_SHARED: 写⼊映射区的数据会复制回⽂件,
* 且允许其他映射该⽂件的进程共享。
* (2) MAP_PRIVATE: 对映射区的写⼊操作
* 会产⽣⼀个映射区的复制(copy - on - write),
* 对此区域所做的修改不会写回原⽂件。
* @param fd 由open返回的⽂件描述符, 代表要映射的⽂件.
* @param offset 以⽂件开始处的偏移量,
* 必须是4k的整数倍, 通常为0, 表示从⽂件头开始映射.
* @return 成功：返回创建的映射区⾸地址; 失败：MAP_FAILED宏.
*/
void *mmap(void *addr, size_t length,
int prot, int flags, int fd, off_t offset);
```

>内存是按照⻚来区别的，通常⼀⻚就是4K

总结：

1. 第⼀个参数写成NULL
2. 第⼆个参数要映射的⽂件⼤⼩ > 0
3. 第三个参数：PROT_READ 、PROT_WRITE
4. 第四个参数：MAP_SHARED 或者 MAP_PRIVATE
5. 第五个参数：打开的⽂件对应的⽂件描述符
6. 第六个参数：4k的整数倍，通常为0

##### munmap函数

```cpp
#include <sys/mman.h>
/**
* 释放内存映射区.
* @param addr 使⽤mmap函数创建的映射区的⾸地址.
* @param length 映射区的⼤⼩.
* @return 成功返回0; 失败返回-1.
*/
int munmap(void *addr, size_t length);
```

#### 注意事项

1. 创建映射区的过程中，隐含着⼀次对映射⽂件的读操作
2. 当MAP_SHARED时，要求：映射区的权限应 <=⽂件打开的权限(出于对映射区的保护)。⽽MAP_PRIVATE则⽆所谓，因为mmap中的权限是对内存的限制
3. 映射区的释放与⽂件关闭⽆关。只要映射建⽴成功，⽂件可以⽴即关闭
4. 特别注意，当映射⽂件⼤⼩为0时，不能创建映射区。所以，⽤于映射的⽂件必须要有实际⼤⼩。mmap使⽤时常常会出现总线错误，通常是由于共享⽂件存储空间⼤⼩引起的
5. munmap传⼊的地址⼀定是mmap的返回地址。坚决杜绝指针++操作
6. 如果⽂件偏移量必须为4K的整数倍
7. mmap创建映射区出错概率⾮常⾼，⼀定要检查返回值，确保映射区建⽴成功再进⾏后续操作

#### 匿名映射实现⽗⼦进⾏通信

（1）为什么使⽤匿名的⽅式实现通信？
内存映射的需要依赖⽂件。⽽建⽴⽂件建⽴好了只会还要unlink close掉，⽐较麻烦;
（2）有什么好的不能办法进⾏解决？
直接使⽤匿名映射来代替;
（3）Linux系统给我们提供了创建匿名映射区的⽅法，⽆需依赖⼀个⽂件即可创建映射区。同样需要借助标志位参数flags来指定;
（4）使⽤MAP_ANONYMOUS (或MAP_ANON):

```cpp
int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
```

### 消息队列

基本原理：A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时
候再去读取数据就可以了。

特点：

1. 消息队列是保存在内核中的消息链表，每个消息体都是固定⼤⼩的存储块。如果进程从消息队列中读取了消息
体，内核就会把这个消息体删除。
2. 如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在。

缺点：

1. 通信不及时，附件也有⼤⼩限制。
2. 消息队列不适合⽐较⼤数据的传输，每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所包含的全部消息体的总⻓度也是有上限
3. 消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销

### 信号

信号是linux进程通信的最古⽼的⽅式
信号是软件中断，它是在软件层次上对中断机制的⼀种模拟，是⼀种异步通信的⽅式 。信号可以导致⼀个正在运⾏的进程被另⼀个正在运⾏的异步进程中断，转⽽处理某⼀个突发事件
信号可以直接进⾏⽤户空间进程和内核空间进程的交互，内核进程可以利⽤它来通知⽤户空间进程发⽣了哪些系统事件

#### 信号的特点

1. 简单
2. 不能携带⼤量信息
3. 满⾜某个特定条件才发送

#### ⼀个完整的信号周期

1. 信号的产⽣
2. 信号在进程种的注册，信号在进程种的注销
3. 执⾏信号处理函数

#### 信号编号

（1）不存在编号为0的信号

1. 其中1-31号信号称之为常规信号（也叫普通信号或标准信号）
2. 34-64称之为实时信号，驱动编程与硬件相关。名字上区别不⼤。⽽前32个名字各不相同

（2）不存在编号为0的号，也没有32-33号

（3）⽐较重要的⼀些，需要记住的⼏个信号

1. SIGINT 当⽤户按下了<Ctrl+C>组合键时，⽤户终端向正在运⾏中的由该终端启动的程序发出此信号，终⽌进程
2. SIGQUIT ⽤户按下<ctrl+>组合键时产⽣该信号，⽤户终端向正在运⾏中的由该终端启动的程序发出些信号,终⽌进程
3. SIGSEGV 指示进程进⾏了⽆效内存访问(段错误), 终⽌进程并产⽣core⽂件
4. SIGPIPE Broken pipe向⼀个没有读端的管道写数据,终⽌进程
5. SIGCHLD ⼦进程结束时，⽗进程会收到这个信号,忽略这个信号

#### 信号四要素

1. 编号: man 7 signal 查看⽂档帮助
2. 名称
3. 事件
4. 默认处理动作:
   1. Term：终⽌进程
   2. Ign： 忽略信号 (默认即时对该种信号忽略操作)
   3. Core：终⽌进程，⽣成Core⽂件。(查验死亡原因，⽤于gdb调试)
   4. Stop：停⽌（暂停）进程
   5. Cont：继续运⾏进程

特别强调: SIGKILL 和 SIGSTOP信号，不允许忽略和捕捉，只能执⾏默认动作。甚⾄不能将其设置为阻塞.

#### 信号的状态

1. 产⽣
   1. 当⽤户按某些终端键时，将产⽣信号
   2. 硬件异常将产⽣信号
   3. 软件异常将产⽣信号
   4. 调⽤系统函数(如：kill、raise、abort)将发送信号
   5. 运⾏ kill /killall命令将发送信号
2. 未决状态：没有被处理
3. 递达状态：信号被处理了

#### 阻塞信号集和未决信号集

##### 阻塞信号集

将某些信号加⼊集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发⽣在解除屏
蔽后)

##### 未决信号集合

信号产⽣，未决信号集中描述该信号的位⽴刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。
这⼀时刻往往⾮常短暂

#### 信号产⽣函数

##### kill函数

```cpp
#include <sys/types.h>
#include <signal.h>
/**
* 给指定进程发送指定信号(不⼀定杀死).
* @param pid 取值有四种情况：
* pid > 0: 将信号传送给进程 ID 为pid的进程.
* pid = 0 : 将信号传送给当前进程所在进程组中的所有进程.
* pid = -1 : 将信号传送给系统内所有的进程.
* pid < -1 : 将信号传给指定进程组的所有进程，这个进程组号等于 pid 的绝对值.
* @param sig 信号的编号，这⾥可以填数字编号，也可以填信号的宏定义.
* 可以通过命令 kill - l("l" 为字⺟)进⾏相应查看.
* 不推荐直接使⽤数字，应使⽤宏名，因为不同操作系统信号编号可能不同，但名称⼀致.
* @return 成功: 0; 失败: -1.
* 普通⽤户基本规则是：发送者实际或有效⽤户ID == 接收者实际或有效⽤户ID.
*/
int kill(pid_t pid, int sig);
```

##### raise函数

```cpp
#include <signal.h>
/**
* 给当前进程发送指定信号(⾃⼰给⾃⼰发)，等价于 kill(getpid(), sig).
* @param sig 信号编号.
* @return 成功: 0; 失败: ⾮0值.
*/
int raise(int sig);
```

##### abort函数

```cpp
#include <stdlib.h>
/**
* 给⾃⼰发送异常终⽌信号 6) SIGABRT，并产⽣core⽂件，等价于kill(getpid(), SIGABRT).
*/
void abort(void);
```

##### alarm函数(闹钟)

```cpp
#include <unistd.h>
/**
* 设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终
⽌。每个进程都有且只有唯⼀的⼀个定时器;
* 取消定时器alarm(0)，返回旧闹钟余下秒数.
* @param seconds 指定的时间，以秒为单位.
* @return 返回0或剩余的秒数.
* /
unsigned int alarm(unsigned int seconds);
```

##### setitimer函数（定时器）

```cpp
#include <sys/time.h>
struct itimerval {
 struct timerval it_interval; // 闹钟触发周期
 struct timerval it_value; // 闹钟触发时间
};
struct timeval {
 long tv_sec; // 秒
 long tv_usec; // 微秒
}
/**
* 设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时.
* @param which 指定定时⽅式:
* (1) ⾃然定时：ITIMER_REAL → 14）SIGALRM计算⾃然时间;
* (2) 虚拟空间计时(⽤户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM 只计算进程占⽤cpu
的时间;
* (3) 虚拟空间计时(⽤户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM 只计算进程占⽤cpu
的时间.
* @param new_value 负责设定timeout时间.
* @param old_value 存放旧的timeout值，⼀般指定为NULL.
* @return 成功: 0; 失败: -1.
*/
int setitimer(int which, const struct itimerval *new_value, struct itimerval
*old_value);
// itimerval.it_value： 设定第⼀次执⾏function所延迟的秒数
// itimerval.it_interval： 设定以后每⼏秒执⾏function
```

#### ⾃定义信号集函数

```cpp
#include <signal.h> 
int sigemptyset(sigset_t *set); // 将set集合置空
int sigfillset(sigset_t *set); // 将所有信号加⼊set集合
int sigaddset(sigset_t *set, int signo); // 将signo信号加⼊到set集合
int sigdelset(sigset_t *set, int signo); // 从set集合中移除signo信号
int sigismember(const sigset_t *set, int signo); // 判断信号是否存在
```

除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图;

#### 阻塞信号集

（1）信号阻塞集也称信号屏蔽集、信号掩码;
（2）信号阻塞集⽤来描述哪些信号递送到该进程的时候被阻塞;
（3）sigprocmask函数

```cpp
#include <signal.h>
/**
* 检查或修改信号阻塞集，根据 how 指定的⽅法对进程的阻塞集合进⾏修改，
* 新的信号阻塞集由 set 指定，⽽原先的信号阻塞集合由 oldset 保存.
*
* @param how 信号阻塞集合的修改⽅法，有 3 种情况:
* (1) SIG_BLOCK：向信号阻塞集合中添加 set 信号集，
* 新的信号掩码是set和旧信号掩码的并集。相当于 mask = mask|set;
* (2) SIG_UNBLOCK：从信号阻塞集合中删除 set 信号集，
* 从当前信号掩码中去除 set 中的信号。相当于 mask = mask & ~ set;
* (3) SIG_SETMASK：将信号阻塞集合设为 set 信号集，
* 相当于原来信号阻塞集的内容清空，然后按照 set 中的信号重新设置信号阻塞集。相当于
mask = set.
*
* @set 要操作的信号集地址,若 set 为 NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到
oldset 中.
* @oldset 保存原先信号阻塞集地址.
* @return 成功: 0; 失败: -1，失败时错误代码只可能是 EINVAL，表示参数 how 不合法.
*/
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

（4）sigpending函数

```cpp
#include <signal.h>
/**
* 读取当前进程的未决信号集.
* @param set 未决信号集.
* @return 成功: 0; 失败: -1.
*/
int sigpending(sigset_t *set);
```

#### 信号捕捉

>注意: SIGKILL 和 SIGSTOP 不能更改信号的处理⽅式，因为它们向⽤户提供了⼀种使进程终⽌的可靠⽅法;

（1）sigaction函数

```cpp
#include <signal.h>
/**
* 检查或修改指定信号的设置（或同时执⾏这两种操作）.
* @param signum 要操作的信号.
* @param act 要设置的对信号的新处理⽅式（传⼊参数）.
* @param oldact：原来对信号的处理⽅式（传出参数）.
*
* 如果 act 指针⾮空，则要改变指定信号的处理⽅式（设置），
* 如果 oldact 指针⾮空，则系统将此前指定信号的处理⽅式存⼊ oldact.
*
* @return 成功: 0; 失败: -1.
*/
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

（2）sa_handler、sa_sigaction：信号处理函数指针

和 signal() ⾥的函数指针⽤法⼀样，应根据情况给sa_sigaction、sa_handler 两者之⼀赋值，其取值如下：

1. SIG_IGN：忽略该信号
2. SIG_DFL：执⾏系统默认动作
3. 处理函数名：⾃定义信号处理函数

（3）sa_mask：
信号阻塞集，在信号处理函数执⾏过程中，临时屏蔽指定的信号;

（4）sa_flags：
⽤于指定信号处理的⾏为，通常设置为0，表使⽤默认属性。它可以是⼀下值的“按位或”组合：

1. A_RESTART：使被信号打断的系统调⽤⾃动重新发起（已经废弃）
2. SA_NOCLDSTOP：使⽗进程在它的⼦进程暂停或继续运⾏时不会收到 SIGCHLD 信号
3. SA_NOCLDWAIT：使⽗进程在它的⼦进程退出时不会收到 SIGCHLD 信号，这时⼦进程如果退出也不会成为僵⼫进程
4. SA_NODEFER：使对信号的屏蔽⽆效，即在信号处理函数执⾏期间仍能发出这个信号
5. SA_RESETHAND：信号处理之后重新设置为默认的处理⽅式
6. SA_SIGINFO：使⽤ sa_sigaction 成员⽽不是 sa_handler 作为信号处理函数

#### struct sigaction结构体

```cpp
struct sigaction {
    void(*sa_handler)(int); //旧的信号处理函数指针
    void(*sa_sigaction)(int, siginfo_t *, void *); //新的信号处理函数指针
    sigset_t sa_mask; //信号阻塞集
    int sa_flags; //信号处理的⽅式
    void(*sa_restorer)(void); //已弃⽤
};
```

#### 信号处理函数

```cpp
/**
* @param signum 信号的编号.
* @param info 记录信号发送进程信息的结构体.
* @param context 可以赋给指向 ucontext_t 类型的⼀个对象的指针
* 以引⽤在传递信号时被中断的接收进程或线程的上下⽂.
*/
void(*sa_sigaction)(int signum, siginfo_t *info, void *context);
```

#### 不可重⼊、可重⼊函数

如果有⼀个函数不幸被设计成为这样：那么不同任务调⽤这个函数时可能修改其他任务调⽤这个函数的数据，从⽽导致不可预料的后果。
这样的函数是不安全的函数，也叫不可重⼊函数;

（1）不可重⼊函数:

1. 函数体内使⽤了静态的数据结构;
2. 函数体内调⽤了malloc() 或者 free() 函数(谨慎使⽤堆);
3. 函数体内调⽤了标准 I/O 函数;

（2）可重⼊函数:

1. 所谓可重⼊是指⼀个可以被多个任务调⽤的过程，任务在调⽤时不必担⼼数据是否会出错;
2. 在写函数时候尽量使⽤局部变量（例如寄存器、栈中的变量）;
3. 对于要使⽤的全局变量要加以保护（如采取关中断、信号量等互斥⽅法），这样构成的函数就⼀定是⼀个可重⼊的函数.

#### SIGCHLD信号

1. ⼦进程终⽌时;
2. ⼦进程接收到SIGSTOP信号停⽌时;
3. ⼦进程处在停⽌态，接受到SIGCONT后唤醒时。

#### 如何避免僵⼫进程

（1）最简单的⽅法:
⽗进程通过 wait() 和 waitpid() 等函数等待⼦进程结束，但是，这会导致⽗进程挂起;
（2）如果⽗进程要处理的事情很多，不能够挂起，通过 signal() 函数⼈为处理信号 SIGCHLD:
只要有⼦进程退出⾃动调⽤指定好的回调函数，因为⼦进程结束后， ⽗进程会收到该信号 SIGCHLD ，可以在其回调函数⾥调⽤ wait() 或 waitpid() 回收;
（3）如果⽗进程不关⼼⼦进程什么时候结束，那么可以⽤signal（SIGCHLD, SIG_IGN）通知内核:
⾃⼰对⼦进程的结束不感兴趣，⽗进程忽略此信号，那么⼦进程结束后，内核会回收，并不再给⽗进程发送信号;

### 守护进程

1. 进程组概述
   1. 代表⼀个或多个进程的集合;
   2. 每个进程都属于⼀个进程组;
   3. 是为了简化对多个进程的管理。

2. 会话
   1. ⼀个会话可以有⼀个控制终端。这通常是终端设备或伪终端设备;
   2. 建⽴与控制终端连接的会话⾸进程被称为控制进程;
   3. ⼀个会话中的⼏个进程组可被分为⼀个前台进程组以及⼀个或多个后台进程组;
   4. 如果⼀个会话有⼀个控制终端，则它有⼀个前台进程组，其它进程组为后台进程组;
   5. 如果终端接⼝检测到断开连接，则将挂断信号发送⾄控制进程（会话⾸进程。

3. 创建会话注意事项
   1. 调⽤进程不能是进程组组⻓，该进程变成新会话⾸进程(session header);
   2. 该调⽤进程是组⻓进程，则出错返回;
   3. 该进程成为⼀个新进程组的组⻓进程;
   4. 需有root权限(ubuntu不需要);
   5. 新会话丢弃原有的控制终端，该会话没有控制终端;
   6. 建⽴新会话时，先调⽤fork, ⽗进程终⽌，⼦进程调⽤setsid。

4. API函数
   1. getsid 函数

        ```cpp
        #include <unistd.h>
        /**
        * 获取进程所属的会话ID.
        * @param pid 进程号，pid为0表示查看当前进程session ID.
        * @return 成功: 返回调⽤进程的会话ID; 失败: -1.
        */
        pid_t getsid(pid_t pid);
        ```

   2. setsid函数

        ```cpp
        #include <unistd.h>
        /**
        * 创建⼀个会话，并以⾃⼰的ID设置进程组ID，同时也是新会话的ID。
        * 调⽤了setsid函数的进程，既是新的会⻓，也是新的组⻓.
        *
        * @return 成功： 返回调⽤进程的会话ID; 失败: -1.
        */
        pid_t setsid(void);
        ```

5. 守护进程
守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程
   1. 它是⼀个⽣存期较⻓的进程，通常独⽴于控制终端并且周期性地执⾏某种任务或等待处理某些发⽣的事件
   2. ⼀般采⽤以d结尾的名字
   3. 所有的服务存在于 etc/init.d
   4. 守护进程是个特殊的孤⼉进程
   5. 之所以脱离于终端是为了避免进程被任何终端所产⽣的信息所打断，其在执⾏过程中的信息也不在任何终端上显示 
   6. Linux 的⼤多数服务器就是⽤守护进程实现的

6. 守护进程模型
   1. 创建⼦进程，⽗进程退出(必须)
    所有⼯作在⼦进程中进⾏形式上脱离了控制终端
   2. 在⼦进程中创建新会话(必须)
      1. setsid()函数
      2. 使⼦进程完全独⽴出来，脱离控制
   3. 改变当前⽬录为根⽬录(不是必须)
      1. chdir()函数
      2. 防⽌占⽤可卸载的⽂件系统
      3. 也可以换成其它路径
   4. 重设⽂件权限掩码(不是必须)
      1. umask()函数
      2. 防⽌继承的⽂件创建屏蔽字拒绝某些权限
      3. 增加守护进程灵活性
   5. 关闭⽂件描述符(不是必须)
    继承的打开⽂件不会⽤到，浪费系统资源，⽆法卸载
   6. 开始执⾏守护进程核⼼⼯作(必须)
    守护进程退出处理程序模型

## 互斥与同步

### 互斥锁Mutex

#### 互斥锁（mutex）

也叫互斥量，互斥锁是⼀种简单的加锁的⽅法来控制对共享资源的访问，互斥锁只有两种状态,即加锁(lock)和解锁(unlock)

1. 在访问共享资源后临界区域前，对互斥锁进⾏加锁。
2. 在访问完成后释放互斥锁导上的锁。
3. 对互斥锁进⾏加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。

互斥锁的数据类型是： `pthread_mutex_t`

##### 创建互斥锁

`pthread_mutex_init()`

```cpp
#include <pthread.h>
/**
* 初始化⼀个互斥锁.
* @param mutex 互斥锁地址。类型是 pthread_mutex_t.
* @param attr 设置互斥量的属性，通常可采⽤默认属性，即可将 attr 设为 NULL.
* @return 成功: 0 成功申请的锁默认是打开的; 失败: ⾮0(错误码).
*/
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
const pthread_mutexattr_t *restrict attr);
// 这种⽅法等价于使⽤ NULL 指定的 attr 参数调⽤ pthread_mutex_init() 来完成动态初始化，
// 不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进⾏错误检查。
```

##### 销毁互斥锁

`pthread_mutex_destroy()`

```cpp
#include <pthread.h>
/**
* 销毁指定的⼀个互斥锁。互斥锁在使⽤完毕后，必须要对互斥锁进⾏销毁，以释放资源.
* @param mutex 互斥锁地址。类型是 pthread_mutex_t.
* @return 成功: 0; 失败: ⾮0(错误码).
*/
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

##### 互斥锁上锁

`pthread_mutex_lock()`

```cpp
#include <pthread.h>
/**
* 对互斥锁上锁，若互斥锁已经上锁，则调⽤者阻塞，直到互斥锁解锁后再上锁.
* @param mutex 互斥锁地址.
* @return 成功: 0; 失败: ⾮0(错误码).
*/
int pthread_mutex_lock(pthread_mutex_t *mutex);
/**
* 调⽤该函数时，若互斥锁未加锁，则上锁，返回 0;
* 若互斥锁已加锁，则函数直接返回失败，即 EBUSY.
*/
int pthread_mutex_trylock(pthread_mutex_t *mutex);
```

##### 互斥锁解锁

`pthread_mutex_unlock()`

```cpp
#include <pthread.h>
/**
* 对指定的互斥锁解锁.
* @param mutex 互斥锁地址.
* @return 成功: 0; 失败: ⾮0(错误码)
*/
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

#### 死锁（DeadLock）

如果⼀个进程集合中的每⼀个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁

##### 资源

1、可抢占资源
可以从拥有它的进程中抢占⽽不会产⽣任何副作⽤，存储器就是⼀类可抢占资源

2、不可抢占资源
是指在不引起相关计算失败的情况下，⽆法把它从占有它的进程处抢占过来

##### 必要条件

1. 互斥
每个资源要么已经分配给⼀个进程，要么就是可⽤的
2. 占有和等待
已经得到了某个资源的进程可以再请求新的资源
3. 不可抢占
已经分配给⼀个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放
4. 环路等待
死锁发⽣时，系统中⼀定有由两个或两个以上的进程组成的⼀条环路，该环路中的每个进程都在等待着下⼀个进程所占有的资源。

##### 处理⽅法

###### 鸵⻦算法

把头埋在沙⼦⾥，假装根本没发⽣问题。
因为解决死锁问题的代价很⾼，因此鸵⻦算法这种不采取任务措施的⽅案会获得更⾼的性能。
当发⽣死锁时不会对⽤户造成多⼤影响，或发⽣死锁的概率很低，可以采⽤鸵⻦算法。

###### 死锁检测与死锁恢复

（1）每种类型⼀个资源的死锁检测

**检测算法：**
通过检测有向图中是否存在环来实现，从⼀个节点出发进⾏深度优先搜索，对访问过的节点进⾏标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁发⽣

（2）每种类型多个资源的死锁检测

**锁检测算法如下：**
每个进程最开始时都不被标记，执⾏过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找⼀个没有标记的进程Pi，它所请求的资源⼩于或等于A 
2. 如果真找到这样⼀个进程，那么将C矩阵的第i⾏向量加到A中，标记该进程，并转回第1步
3. 如果没有这样的进程，那么算法终⽌

###### 从死锁中恢复

（1）利⽤抢占恢复
将进程挂起，强⾏取⾛资源给另⼀个进程使⽤，⽤完再放回

（2）利⽤回滚恢复
复位到更早的状态，那时它还没有取得所需的资源

（3）通过杀死进程恢复
杀掉环中的⼀个进程或多个，牺牲掉⼀个环外进程

###### 死锁预防

（1）破坏互斥条件
例如假脱机打印机技术允许若⼲个进程同时输出，唯⼀真正请求物理打印机的进程是打印机守护进程。

（2）破坏占有个等待条件

1. 规定所有进程在开始执⾏前请求所需要的全部资源。 
2. 要求当⼀个进程请求资源时，先暂时释放其当前占⽤的所有资源，然后在尝试⼀次获得所需的全部资源。

（3）破坏不可抢占条件

1. 保证每⼀个进程在任何时刻只能占⽤⼀个资源，如果请求另⼀个资源必须先释放第⼀个资源
2. 将所有的资源统⼀编号，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序(升序)提出

（4）破坏环路等待

###### 死锁避免

（1）安全状态
如果没有死锁发⽣，并且即使所有进程突然请求对资源的最⼤需求，也仍然存在某种调度次序能够使得每⼀个进程
运⾏完毕，则称该状态是安全的。

（2）单个资源的银⾏家算法
⼀个⼩城镇的银⾏家，他向⼀群客户分别承诺了⼀定的贷款额度，算法要做的是判断对请求的满⾜是否会进⼊不安
全状态，如果是，就拒绝请求；否则予以分配。

（3）多个资源的银⾏家算法
检查⼀个状态是否安全的算法

1. 查找右边的矩阵是否存在⼀⾏⼩于等于向量 A。如果不存在这样的⾏，那么系统将会发⽣死锁，状态是不安全
的。
2. 假若找到这样⼀⾏，将该进程标记为终⽌，并将其已分配资源加到 A 中。
3. 重复以上两步，直到所有进程都标记为终⽌，则状态时安全的。

如果⼀个状态不是安全的，需要拒绝进⼊这个状态。

### 读写锁

在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应⽤。 
为了满⾜当前能够允许多个读出，但只允许⼀个写⼊的需求，线程提供了读写锁来实现。

#### 读写锁的特点

1. 如果有其它线程读数据，则允许其它线程执⾏读操作，但不允许写操作
2. 如果有其它线程写数据，则其它线程都不允许读、写操作

#### 读写锁分为读锁和写锁，规则如下

1. 如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁。 
2. 如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。

POSIX 定义的读写锁的数据类型是： pthread_rwlock_t。

#### 读写锁的使用

##### 初始化读写锁

`pthread_rwlock_init()`

```cpp
/**
* ⽤来初始化 rwlock 所指向的读写锁.
* @param rwlock 指向要初始化的读写锁指针.
* @param attr：读写锁的属性指针。如果 attr 为 NULL 则会使⽤默认的属性初始化读写锁，否则使⽤指定的
attr 初始化读写锁.
* 可以使⽤宏 PTHREAD_RWLOCK_INITIALIZER 静态初始化读写锁，⽐如:
* pthread_rwlock_t my_rwlock = PTHREAD_RWLOCK_INITIALIZER;
* 这种⽅法等价于使⽤ NULL 指定的 attr 参数调⽤ pthread_rwlock_init() 来完成动态初始化，
* 不同之处在于PTHREAD_RWLOCK_INITIALIZER 宏不进⾏错误检查.
* @return 成功: 0，读写锁的状态将成为已初始化和已解锁; 失败: ⾮ 0 错误码.
*/
#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
const pthread_rwlockattr_t *restrict attr);
```

##### 销毁读写锁

`pthread_rwlock_destroy()`

```cpp
/**
* ⽤于销毁⼀个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init() ⾃动申请的资
源.
* @param rwlock 读写锁指针.
* @return 成功: 0; 失败: ⾮0错误码.
*/
#include <pthread.h>
int pthread_rwlock_destroy(pthread_rwlock_
```

##### 读锁定

`pthread_rwlock_rdlock()`

```cpp
#include <pthread.h>
/**
* 以阻塞⽅式在读写锁上获取读锁（读锁定）.
* 如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调⽤线程会获取读锁.
* 如果调⽤线程未获取读锁，则它将阻塞直到它获取了该锁。⼀个线程可以在⼀个读写锁上多次执⾏读锁定.
* 线程可以成功调⽤ pthread_rwlock_rdlock() 函数 n 次，但是之后该线程必须调⽤
pthread_rwlock_unlock() 函数 n 次才能解除锁定.
* @param rwlock 读写锁指针.
* @return 成功: 0; 失败: ⾮0错误码.
*/
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
/**
* ⽤于尝试以⾮阻塞的⽅式来在读写锁上获取读锁.
* 如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则⽴即失败返回.
*/
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
```

##### 写锁定

`pthread_rwlock_wrlock()`

```cpp
#include <pthread.h>
/**
* 在读写锁上获取写锁（写锁定）.
* 如果没有写者持有该锁，并且没有写者读者持有该锁，则调⽤线程会获取写锁.
* 如果调⽤线程未获取写锁，则它将阻塞直到它获取了该锁.
* @param rwlock 读写锁指针.
* @return 成功: 0; 失败: ⾮0错误码.
*/
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
/**
* ⽤于尝试以⾮阻塞的⽅式来在读写锁上获取写锁.
* 如果有任何的读者或写者持有该锁，则⽴即失败返回.
*/
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
```

##### 解锁

`pthread_rwlock_unlock()`

```cpp
#include <pthread.h>
/**
* ⽆论是读锁或写锁，都可以通过此函数解锁.
* @param rwlock 读写锁指针.
* @return 成功: 0; 失败: ⾮0错误码.
*/
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

### 条件变量

与互斥锁不同，条件变量是⽤来等待⽽不是⽤来上锁的，条件变量本身不是锁！
条件变量⽤来⾃动阻塞⼀个线程，直到某特殊情况发⽣为⽌。通常条件变量和互斥锁同时使⽤。

**条件变量的两个动作**：

1. 条件不满, 阻塞线程
2. 当条件满⾜, 通知阻塞的线程开始⼯作

条件变量的类型: **pthread_cond_t**

#### 创建条件变量

`pthread_cond_init()`

```cpp
#include <pthread.h>
/**
* 初始化⼀个条件变量.
* @param cond 指向要初始化的条件变量指针.
* @param attr 条件变量属性，通常为默认值，传NULL即可.
* 也可以使⽤静态初始化的⽅法，初始化条件变量;
* pthread_cond_t cond = PTHREAD_COND_INITIALIZER.
* return 成功: 0; 失败: ⾮0错误号.
*/
int pthread_cond_init(pthread_cond_t *restrict cond,
const pthread_condattr_t *restrict attr);
```

#### 删除条件变量

`pthread_cond_destroy()`

```cpp
#include <pthread.h>
/**
* 销毁⼀个条件变量.
* @param cond 指向要初始化的条件变量指针.
* @return 成功: 0; 失败: ⾮0错误号.
*/
int pthread_cond_destroy(pthread_cond_t *cond);
```

#### 唤醒线程

`pthread_cond_signal()`

```cpp
#include <pthread.h>
/**
* 唤醒⾄少⼀个阻塞在条件变量上的线程.
* @param cond 指向要初始化的条件变量指针.
* @return 成功: 0; 失败: ⾮0错误号.
*/
int pthread_cond_signal(pthread_cond_t *cond);
/**
* 唤醒全部阻塞在条件变量上的线程.
* @param cond 指向要初始化的条件变量指针.
* @return 成功: 0; 失败: ⾮0错误号.
*/
int pthread_cond_broadcast(pthread_cond_t *cond);
```

#### 阻塞线程

`pthread_cond_wait()`

```cpp
#include <pthread.h>
struct timespec {
 time_t tv_sec; /* seconds */ // 秒
 long tv_nsec; /* nanosecondes*/ // 纳秒
}
// time_t cur = time(NULL); //获取当前时间。
// struct timespec t; //定义timespec 结构体变量t
// t.tv_sec = cur + 1; // 定时1秒
// pthread_cond_timedwait(&cond, &t);
/**
* 阻塞等待⼀个条件变量
* 1. 阻塞等待条件变量cond（参1）满⾜
* 2. 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&mutex);
* ((1), (2)两步为⼀个原⼦操作)
* 3. 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁
pthread_mutex_lock(&mutex);
* @param cond 指向要初始化的条件变量指针.
* @param mutex 互斥锁.
* @return 成功: 0; 失败: ⾮0错误号.
*/
int pthread_cond_wait(pthread_cond_t *restrict cond,
 pthread_mutex_t *restrict mutex);
/**
* 限时等待⼀个条件变量.
* @param cond 指向要初始化的条件变量指针.
* @param mutex 互斥锁.
* @param abstime 绝对时间.
* @return 成功: 0; 失败: ⾮0错误号.
*/
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
 pthread_mutex_t *restrict mutex,
 const struct *restrict abstime);
```

#### 条件变量流程分析

##### 条件变量的优缺点

相较于mutex⽽⾔，**条件变量可以减少竞争**。
如直接使⽤mutex，除了⽣产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量。
但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是⽆意义的。
有了条件变量机制以后，只有⽣产者完成⽣产，才会引起消费者之间的竞争。提⾼了程序效率。

##### 条件变量流程分析

场景: 你是个⽼板，招聘了三个员⼯，但是你不是有了活才去招聘员⼯，⽽是先把员⼯招来，没有活的时候员⼯需
要在那⾥等着，⼀旦有了活，你要去通知他们，他们要去抢活⼲，⼲完了再等待，你再有活，再通知他们

代码如下：

```cpp
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#define NUM_OF_TASKS 3
#define MAX_TASK_QUEUE 11
char tasklist[MAX_TASK_QUEUE] = "ABCDEFGHIJ";
int head = 0;
int tail = 0;
int quit = 0;
pthread_mutex_t g_task_lock;
pthread_cond_t g_task_cv;
void *coder(void *notused)
{
    pthread_t tid = pthread_self();
    while (!quit)
    {
        pthread_mutex_lock(&g_task_lock);
        while (tail == head)
        {
            if (quit)
            {
                pthread_mutex_unlock(&g_task_lock);
                pthread_exit((void *)0);
            }
            printf("No task now! Thread %u is waiting!\n", (unsigned int)tid);
            pthread_cond_wait(&g_task_cv, &g_task_lock);
            printf("Have task now! Thread %u is grabing the task !\n", (unsigned int)tid);
        }
        char task = tasklist[head++];
        pthread_mutex_unlock(&g_task_lock);
        printf("Thread %u has a task %c now!\n", (unsigned int)tid, task);
        sleep(5);
        printf("Thread %u finish the task %c!\n", (unsigned int)tid, task);
    }
    pthread_exit((void *)0);
}
int main(int argc, char *argv[])
{
    pthread_t threads[NUM_OF_TASKS];
    int rc;
    int t;
    pthread_mutex_init(&g_task_lock, NULL);
    pthread_cond_init(&g_task_cv, NULL);
    for (t = 0; t < NUM_OF_TASKS; t++)
    {
        rc = pthread_create(&threads[t], NULL, coder, NULL);
        if (rc)
        {
            printf("ERROR; return code from pthread_create() is %d\n", rc);
            exit(-1);
        }
    }
    sleep(5);
    for (t = 1; t <= 4; t++)
    {
        pthread_mutex_lock(&g_task_lock);
        tail += t;
        printf("I am Boss, I assigned %d tasks, I notify all coders!\n", t);
        pthread_cond_broadcast(&g_task_cv);
        pthread_mutex_unlock(&g_task_lock);
        sleep(20);
    }
    pthread_mutex_lock(&g_task_lock);
    quit = 1;
    pthread_cond_broadcast(&g_task_cv);
    pthread_mutex_unlock(&g_task_lock);
    pthread_mutex_destroy(&g_task_lock);
    pthread_cond_destroy(&g_task_cv);
    pthread_exit(NULL);
}
```

下⾯是对于每个输出的分析：

```s
No task now! Thread 1461831424 is waiting!
No task now! Thread 1453438720 is waiting!
No task now! Thread 1445046016 is waiting!
# 这是主线程新建的三个⼯作线程，这时候⼯作线程都是先获得锁，判断tail==head，阻塞，cond_wait释放了锁，三个⼯作线程都等待信号来唤醒

I am Boss, I assigned 1 tasks, I notify all coders!
# 主线程增加了⼀个任务，引起了head!=tail，这时候broadcast唤醒了所有⼯作线程，之后主线程释放锁，开始睡眠20s

Have task now! Thread 1453438720 is grabing the task !
# 1⼯作线程在竞争中抢到了锁，退出了while(tail==head)循环，并开始完成A任务，这时候把头加1，释放锁

Have task now! Thread 1445046016 is grabing the task !
No task now! Thread 1445046016 is waiting!
# 1⼯作线程时间⽚到了，2，3⼯作线程对锁进⾏竞争，2得到了锁，但是这时候已经没有⼯作了。while(tail==head)循环没有退出，因此释放锁，等待唤醒

Thread 1453438720 has a task A now!
# 调度程序调度到1线程执⾏，打印了这句话，开始睡眠5s

Have task now! Thread 1461831424 is grabing the task !
No task now! Thread 1461831424 is waiting!
# 3⼯作线程抢到了锁（虽然这时候只有它在抢锁），3得到了锁，但是这时候已经没有⼯作了。while(tail==head)循环没有退出，因此释放锁，等待唤醒

Thread 1453438720 finish the task A!
No task now! Thread 1453438720 is waiting!
# 20⼯作线程执⾏完任务，这时候还是没有⼯作。先上锁，后进⼊while(tail==head)循环没有退出，因此释放锁，等待唤醒

I am Boss, I assigned 2 tasks, I notify all coders!
# 主线程醒了，⼜找了两个⼯作B,C，唤醒了所有⼯作线程去做

Have task now! Thread 1461831424 is grabing the task !
Thread 1461831424 has a task B now!
# 24号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了

Have task now! Thread 1445046016 is grabing the task !
Thread 1445046016 has a task C now!
# 16号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了

Have task now! Thread 1453438720 is grabing the task !
No task now! Thread 1453438720 is waiting!
# 20号线程抢到了锁，没任务了，就释放锁，等待唤醒

Thread 1445046016 finish the task C!
No task now! Thread 1445046016 is waiting!
# 调度16号线程执⾏，16号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒

Thread 1461831424 finish the task B!
No task now! Thread 1461831424 is waiting
# 调度24号线程执⾏，24号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒 

I am Boss, I assigned 3 tasks, I notify all coders!
# 主线程醒了，⼜找了三个个⼯作D,E,F，唤醒了所有⼯作线程去做 

Have task now! Thread 1461831424 is grabing the task !
Thread 1461831424 has a task D now!
# 24号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了 

Have task now! Thread 1445046016 is grabing the task !
Thread 1445046016 has a task E now!
# 16号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了 

Have task now! Thread 1453438720 is grabing the task !
Thread 1453438720 has a task F now!
# 20号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了 

Thread 1461831424 finish the task D!
No task now! Thread 1461831424 is waiting!
# 调度24号线程执⾏，24号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒 

Thread 1445046016 finish the task E!
No task now! Thread 1445046016 is waiting!
# 调度16号线程执⾏，16号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒 

Thread 1453438720 finish the task F!
No task now! Thread 1453438720 is waiting!
# 调度20号线程执⾏，20号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒 

I am Boss, I assigned 4 tasks, I notify all coders!
# 主线程醒了，⼜找了三个个⼯作G,H,I,J，唤醒了所有⼯作线程去做 

Have task now! Thread 1453438720 is grabing the task !
Thread 1453438720 has a task G now!
# 20号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了 

Have task now! Thread 1461831424 is grabing the task !
Thread 1461831424 has a task H now!
# 24号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了 

Have task now! Thread 1445046016 is grabing the task !
Thread 1445046016 has a task I now!
# 16号线程抢到了锁，执⾏头加1，释放锁，然后睡眠了 

Thread 1453438720 finish the task G!
Thread 1453438720 has a task J now!
# 20号线程执⾏完任务，下⼀轮while中，持有了锁，发现还有任务，就继续做J，执⾏头加1，释放了锁，开始睡眠5s 

Thread 1461831424 finish the task H!
No task now! Thread 1461831424 is waiting!
# 调度24号线程执⾏，24号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒 

Thread 1445046016 finish the task I!
No task now! Thread 1445046016 is waiting!
# 调度16号线程执⾏，16号线程完成任务，得到锁，发现没任务，释放锁，等待唤醒 

Thread 1453438720 finish the task J!
No task now! Thread 1453438720 is waiting!
# 20线程完成任务，下⼀轮while中持有锁，发现没任务了，释放锁，等待唤醒
# 主线程抢锁，设置退出标志quit为1，并通知三个⼯作线程 

Have task now! Thread 1461831424 is grabing the task !
Have task now! Thread 1445046016 is grabing the task !
Have task now! Thread 1453438720 is grabing the task !

# 三个⼯作线程分别抢到了锁，发现quit为1，就释放锁，然后终⽌各⾃的线程
# 主线程销毁了锁和条件变量
# 终⽌了main线程
```

### 信号量

信号量⼴泛⽤于进程或线程间的同步和互斥，信号量本质上是⼀个⾮负的整数计数器，它被⽤来控制对公共资源的访问。
编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值⼤于 0 时，则可以访问，否则将阻塞。
PV 原语是对信号量的操作，⼀次 P 操作使信号量减１，⼀次 V 操作使信号量加１。

信号量数据类型为：**sem_t**

#### 创建信号量

`sem_init()`

```cpp
#include <semaphore.h>
/**
* 创建⼀个信号量并初始化它的值。⼀个⽆名信号量在被使⽤前必须先初始化.
* @param sem 信号量的地址.
* @param pshared 等于 0，信号量在线程间共享（常⽤）; 不等于0，信号量在进程间共享.
* @param value 信号量的初始值.
* @return 成功: 0; 失败: -1.
*/
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

#### 删除信号量

`sem_destroy()`

```cpp
#include <semaphore.h>
/**
* 删除 sem 标识的信号量.
* @return 成功: 0; 失败: -1.
*/
int sem_destroy(sem_t *sem);
```

#### P操作

`sem_wait()(P操作)`

```cpp
#include <semaphore.h>
/**
* 将信号量的值减 1。操作前，先检查信号量（sem）的值是否为 0;
* 若信号量为 0，此函数会阻塞，直到信号量⼤于 0 时才进⾏减 1 操作。
* @param sem 信号量的地址.
* @return 成功: 0; 失败: -1.
*/
int sem_wait(sem_t *sem);
/**
* 以⾮阻塞的⽅式来对信号量进⾏减 1 操作。
* 若操作前，信号量的值等于 0，则对信号量的操作失败，函数⽴即返回。
*/
int sem_trywait(sem_t *sem);
/**
* 限时尝试将信号量的值减 1
* abs_timeout：绝对时间
*/
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

#### V操作

sem_post()(V操作)

```cpp
#include <semaphore.h>
/**
* 将信号量的值加 1 并发出信号唤醒等待线程(sem_wait()).
* @param sem 信号量的地址.
* @return 成功: 0; 失败: -1.
*/
int sem_post(sem_t *sem);
```

#### 获取信号量的值

`sem_getvalue()`

```cpp
#include <semaphore.h>
/**
* 获取 sem 标识的信号量的值，保存在 sval 中.
* @param sem 信号量的地址.
* @param sval 保存信号量值的地址.
* @return 成功: 0; 失败: -1.
*/
int sem_getvalue(sem_t *sem, int *sval);
```

### 管程

使⽤信号量机制实现的⽣产者消费者问题需要客户端代码做很多控制，
⽽管程把控制的代码独⽴出来，不仅不容易出错，也使得客户端代码调⽤更容易。

下⾯是经典的IPC问题

#### 哲学家进餐问题

下⾯是⼀种错误的解法，如果所有哲学家同时拿起左⼿边的筷⼦，那么所有哲学家都在等待其它哲学家吃完并释放⾃⼰⼿中的筷⼦，导致死锁。

```cpp
#define N 5
void philosopher(int i)
{
    while (TRUE)
    {
        think();
        take(i);           // 拿起左边的筷⼦
        take((i + 1) % N); // 拿起右边的筷⼦
        eat();
        put(i);
        put((i + 1) % N);
    }
}
```

为了防⽌死锁的发⽣，可以设置两个条件：

1. 必须同时拿起左右两根筷⼦
2. 只有在两个邻居都没有进餐的情况下才允许进餐

```cpp
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
int state[N];        // 跟踪每个哲学家的状态
semaphore mutex = 1; // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];      // 每个哲学家⼀个信号量
void philosopher(int i)
{
    while (TRUE)
    {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}
void take_two(int i)
{
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会⼀直等下去
}
void put_two(i)
{
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，⾃⼰吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}
void eat(int i)
{
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}
// 检查两个邻居是否都没有⽤餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执⾏
void check(i)
{
    if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING)
    {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

#### 读者-写者问题

允许多个进程同时对数据进⾏读操作，但是不允许读和写以及写和写操作同时发⽣。
⼀个整型变量 count 记录在对数据进⾏读操作的进程数量，⼀个互斥量 count_mutex ⽤于对 count 加锁，⼀个互斥量 data_mutex ⽤于对读写的数据加锁。

```cpp
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;
void reader()
{
    while (TRUE)
    {
        down(&count_mutex);
        count++;
        if (count == 1)
            down(&data_mutex); // 第⼀个读者需要对数据进⾏加锁，防⽌写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if (count == 0)
            up(&data_mutex);
        up(&count_mutex);
    }
}
void writer()
{
    while (TRUE)
    {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```
